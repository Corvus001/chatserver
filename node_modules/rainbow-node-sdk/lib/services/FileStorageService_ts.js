/**
 * @ngdoc service
 * @module rainbow
 * @name FileStorageService
 * @requires $q
 * @requires $http
 * @requires $log
 * @requires $scope
 * @requires authService
 * @requires errorHelperService
 * @requires orderByFilter
 * @requires contactService
 * @requires fileTransfertService
 * @requires $injector
 * @description Rainbow FileStorageService provides interface to maniplate file descriptors of files received or sent by user
 */

/*import { ServiceInterface } from "./../serviceInterface";
import { IFileDescriptor } from "../../models/common/fileDescriptor";
import { IFileViewer } from "../../models/common/fileViewer";
import { IHttpUploadResult } from "../../models/common/httpResult";*/

/// <reference path="../serviceInterface.ts"/>
/// <reference path="../../models/common/fileDescriptor.ts"/>
/// <reference path="../../models/common/httpResult.ts"/>

declare var config: any;
declare var angular: ng.IAngularStatic;

class FileStorageService implements ServiceInterface {

    private started: boolean = false;
    private portalURL: string;
    private fileDescriptors: IFileDescriptor[];
    private receivedFileDescriptors: IFileDescriptor[];
    private fileDescriptorsByDate: IFileDescriptor[];
    private fileDescriptorsByName: IFileDescriptor[];
    private fileDescriptorsBySize: IFileDescriptor[];
    private receivedFileDescriptorsByName: IFileDescriptor[];
    private receivedFileDescriptorsByDate: IFileDescriptor[];
    private receivedFileDescriptorsBySize: IFileDescriptor[];
    private consumptionData: Object;

    private rotationValues: Object = {
        1: "rotate(0deg)",
        3: "rotate(180deg)",
        6: "rotate(90deg)",
        8: "rotate(270deg)"
    };
    static $inject: string[] = [
        "$q",
        "$http",
        "$log",
        "$rootScope",
        "authService",
        "fileViewerFactory",
        "errorHelperService",
        "orderByFilter",
        "contactService",
        "fileTransfertService",
        "helpersService",
        "fileViewerElementFactory",
        "fileDescriptorFactory",
        "$injector"];

    constructor(
        private $q: ng.IQService,
        private $http: ng.IHttpService,
        private $log: ng.ILogService,
        private $rootScope: ng.IScope,
        private authService,
        private fileViewerFactory,
        private errorHelperService,
        private orderByFilter: any,
        private contactService: any,
        private fileTransfertService,
        private helpersService: any,
        private fileViewerElementFactory: any,
        private fileDescriptorFactory: any,
        private $injector) {
    }

    public start(stats) {
        this.$log.info("[FileStorageService] === STARTING ===");

        let startDate = performance.now();
        this.started = false;
        this.portalURL = config.restServerUrl + "/api/rainbow/filestorage/v1.0/files";
        this.fileDescriptors = [];
        this.fileDescriptorsByDate = [];
        this.fileDescriptorsByName = [];
        this.fileDescriptorsBySize = [];
        this.receivedFileDescriptors = [];
        this.receivedFileDescriptorsByName = [];
        this.receivedFileDescriptorsByDate = [];
        this.receivedFileDescriptorsBySize = [];
        this.consumptionData = {};

        // No blocking service
        this.retrieveFileDescriptorsListPerOwner()
            .then(() => {
                return this.retrieveReceivedFiles(this.contactService.userContact.dbId);
            })
            .then(() => {
                this.orderDocuments();
                return this.retrieveUserConsumption();
            })
            .then(() => {
                this.started = true;
                var startDuration = Math.round(performance.now() - startDate);
                stats.push({ service: "FileStorageService", startDuration: startDuration });
                this.$log.info("[FileStorageService] === STARTED (" + startDuration + " ms) ===");
            })
            .catch((error) => {
                this.$log.error("[FileStorageService] === STARTING === failure -- " + error.message);
            });

        return this.$q.when();
    }

    public stop() {
        this.$log.info("[FileStorageService] === STOPPING ===");
        if (this.started) { this.started = false; }
        this.$log.info("[FileStorageService] === STOPPED ===");
        return this.$q.when();
    }

    /**********************************************************/
    /**  Basic accessors to FileStorageService's properties   **/
    /**********************************************************/
    public getFileDescriptorById(id): IFileDescriptor {
        for (let fileDescriptor of this.fileDescriptors) {
            if (fileDescriptor.id === id) { return fileDescriptor; }
        }
        for (let fileDescriptor of this.receivedFileDescriptors) {
            if (fileDescriptor.id === id) { return fileDescriptor; }
        }
        return null;
    }

    /**
     * Method returns a file descriptor with full contact object in viewers'list by requesting server
     * 
     * @param {string} fileId [required] Identifier of file descriptor
     * @returns {ng.IPromise<IFileDescriptor>} file descriptor
     * 
     * @memberOf FileStorageService
     */
    public getCompleteFileDescriptorById(id): ng.IPromise<IFileDescriptor> {
        return this.$q((resolve, reject) => {
            let fileDescriptor: IFileDescriptor;

            if (this.fileDescriptors.some((fd) => { if (fd.id === id) { fileDescriptor = fd; return true; } return false; })) {
                let promiseArray = [];
                //for each viewer ID, associate the contact
                for (let viewer of fileDescriptor.viewers) {
                    if (viewer.type === "user") {
                        promiseArray.push(
                            this.contactService.getContactByDBId(viewer["viewerId"])
                                .then((contact) => {
                                    viewer["contact"] = contact;
                                    return (viewer);
                                })
                                .catch((error) => {
                                    this.$log.error("[FileStorageService] " + error);
                                    reject(error);
                                })
                        );
                    }
                    else {

                    }
                }

                this.$q.all(promiseArray)
                    .then(() => {
                        resolve(fileDescriptor);
                    })
                    .catch((error) => {
                        this.$log.error("[FileStorageService] " + error);
                        reject(error);
                    });

            } else {
                reject();
            }
        });
    }

    public getDocuments(): IFileDescriptor[] {
        return this.fileDescriptors;
    }

    public getReceivedDocuments(): IFileDescriptor[] {
        return this.receivedFileDescriptors;
    }

    public getDocumentsByName(received: boolean): IFileDescriptor[] {
        return received ? this.receivedFileDescriptorsByName : this.fileDescriptorsByName;
    }

    public getDocumentsByDate(received: boolean): IFileDescriptor[] {
        return received ? this.receivedFileDescriptorsByDate : this.fileDescriptorsByDate;
    }

    public getDocumentsBySize(received: boolean): IFileDescriptor[] {
        return received ? this.receivedFileDescriptorsBySize : this.fileDescriptorsBySize;
    }

    public getReceivedFilesFromContact(dbId): IFileDescriptor[] {
        let files = this.receivedFileDescriptorsByDate.filter((file) => {
            return (file.ownerId === dbId);
        });

        return files;
    }

    public getSentFilesToContact(dbId): IFileDescriptor[] {
        let files = this.fileDescriptorsByDate.filter((file) => {
            for (let i = 0; i < file.viewers.length; i++) {
                if (file.viewers[i].viewerId === dbId) {
                    return true;
                }
            }
            return false;
        });

        return files;
    }

    public getReceivedFilesForRoom(dbId): IFileDescriptor[] {
        let files = this.receivedFileDescriptorsByDate.filter((file) => {
            for (let i = 0; i < file.viewers.length; i++) {
                if (file.viewers[i].viewerId === dbId && file.ownerId !== this.contactService.userContact.dbId) {
                    return true;
                }
            }
            return false;
        });

        return files;
    }

    public getConsumptionData(): Object {
        return this.consumptionData;
    }

    /**********************************************************/
    /**  Methods requesting server                           **/
    /**********************************************************/

    /**
     * Method requests server to create a file descriptor this will be saved to local file descriptor list (i.e. this.fileDescriptors)
     * 
     * @param {String} name [required] name of file for which file descriptor has to be created
     * @param {String} extension [required] extension of file
     * @param {number} size [required] size of  file
     * @param {IFileViewer[]} viewers [required] list of viewers having access to the file (a viewer could be either be a user or a room)
     * @returns {ng.IPromise<IFileDescriptor>} file descriptor created by server or error 
     * 
     * @memberof FileStorageService
     */
    public createFileDescriptor(name: string, extension: string, size: number, viewers: IFileViewer[]): ng.IPromise<IFileDescriptor> {

        return this.$q((resolve, reject) => {
            this.$http({
                method: "POST",
                url: this.portalURL,
                headers: this.authService.getRequestHeader(),
                data: { fileName: name, extension: extension, size: size, viewers: viewers }
            })
                .then((response: ng.IHttpPromiseCallbackArg<IHttpUploadResult>) => {
                    const fileDescriptor = this.createFileDescriptorFromData(response.data.data);
                    this.$log.info("[FileStorageService] createFileDescriptor -- " + fileDescriptor.id + " -- success");
                    
                    //in case something went wrong with the creation
                    if (fileDescriptor) {
                        this.fileDescriptors.push(fileDescriptor);
                    }
                    
                    this.orderDocuments();
                    resolve(fileDescriptor);
                })
                .catch((errorResponse) => {
                    const error = this.errorHelperService.handleError(errorResponse, "createFileDescriptor");
                    this.$log.error("[FileStorageService] " + error.message);
                    reject(error);
                });
        });
    }

    public createFileDescriptorFromData(data: any): any {
        if (data) {
            let viewers: IFileViewer[] = [];
            if (data.viewers) {
                for (let viewerData of data.viewers) {
                    viewers.push(this.fileViewerElementFactory(viewerData.viewerId, viewerData.type, viewerData.contact, this.contactService));
                }
            }
            let url = data.url;
            if (!url) { url = config.restServerUrl + "/api/rainbow/fileserver/v1.0/files/" + data.id; }

            var state = "unknown";
            if (data.isUploaded) { state = "uploaded"; }
            else { state = "not_uploaded"; }

            return this.fileDescriptorFactory(data.id, url, data.ownerId, data.fileName, data.extension, data.typeMIME,
                data.size, data.registrationDate, data.uploadedDate, data.dateToSort, viewers, state, data.thumbnail, data.orientation);
        }
        return;
    };

    /**
     * Method request deletion of a file descriptor on the server and removes it from local storage
     * @param {any} id [required] file descriptor id to be destroyed
     * @returns {ng.IPromise<IFileDescriptor[]>} list of remaining file descriptors
     * @memberof FileStorageService
     */
    public deleteFileDescriptor(id): ng.IPromise<IFileDescriptor> {

        return this.$q((resolve, reject) => {
            this.$http({
                method: "DELETE",
                url: this.portalURL + "/" + id,
                headers: this.authService.getRequestHeader()
            })
                .then(() => {
                    this.$log.info("[FileStorageService] deleteFileDescriptor -- success");
                    this.deleteFileDescriptorFromCache(id, false);
                    this.$rootScope.$broadcast("ON_FILE_REMOVED_FROM_STORE_EVENT", { fileId: id });
                    resolve(undefined);
                })
                .catch((errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "deleteFileDescriptor");
                    reject(error);
                    this.$log.error("[FileStorageService] " + error.message);
                });
        });
    }

    /**
     * Method request deletion of all files on the server and removes them from local storage
     * @returns {ng.IPromise<{}>} ???
     * @memberof FileStorageService
     */
    public deleteAllFileDescriptor(): ng.IPromise<{}> {
        return this.$q((resolve, reject) => {
            let promiseArray = [];
            this.fileDescriptors.forEach((fileDescriptor) => {
                if (fileDescriptor.state !== "deleted") {
                    promiseArray.push(
                        this.deleteFileDescriptor(fileDescriptor.id)
                            .then((response) => {
                                return response;
                            })
                    );
                }
            });

            this.$q.all(promiseArray)
                .then(() => { resolve(); })
                .catch((errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "deleteAllFileDescriptor");
                    reject(error);
                });
        });
    }

    /**
     * Method retrieve full list of files belonging to user making the request
     * 
     * @returns {ng.IPromise<IFileDescriptor[]>} 
     * 
     * @memberof FileStorageService
     */
    private retrieveFileDescriptorsListPerOwner(): ng.IPromise<IFileDescriptor[]> {
        this.fileDescriptors = [];
        return this.$q((resolve, reject) => {
            this.$http({
                method: "GET",
                url: this.portalURL + "?format=full&limit=1000",
                headers: this.authService.getRequestHeader()
            })
                .then((response) => {
                    let fileDescriptorsData = response.data["data"];
                    if (!fileDescriptorsData) { resolve(); }

                    // Check if we have received all fileDescriptors
                    let limit = response.data["limit"];
                    let total = response.data["total"];
                    let getAllFileDescriptorPromise = null;

                    // Create the getAllFileDescritor promise
                    if (total <= limit) { getAllFileDescriptorPromise = this.$q.resolve([]); }
                    else {
                        let offset = limit;
                        let requestCount = total / limit;
                        let requestArray = [];
                        for (let index = 1; index < requestCount; index++) {
                            requestArray.push(this.retrieveFileDescriptorsListPerOwnerwithOffset(offset, limit));
                            offset += limit;
                        }
                        getAllFileDescriptorPromise = this.$q.all(requestArray);
                    }

                    // Call the getAllFileDescritor promise
                    getAllFileDescriptorPromise
                        .then((responsesData: [any]) => {
                            // Contact all response in a single array
                            responsesData.forEach((responseData) => { fileDescriptorsData = fileDescriptorsData.concat(responseData); });

                            // Create file descriptors
                            for (let fileDescriptorData of fileDescriptorsData) {
                                let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorData);
                                this.fileDescriptors.push(fileDescriptor);
                            }
                            this.$log.info("[FileStorageService] retrieveFileDescriptorsListPerOwner -- success");
                            resolve(this.fileDescriptors);
                        });
                })
                .catch((errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "retrieveFileDescriptorsListPerOwner");
                    reject(error);
                    this.$log.error("[FileStorageService] " + error.message);
                });
        });
    }

    /**
     * Method retrieve a list of [limit] files belonging to user making the request begining with offset
     * 
     * @returns {ng.IPromise<IFileDescriptor[]>} 
     * 
     * @memberof FileStorageService
     */
    public retrieveFileDescriptorsListPerOwnerwithOffset(offset: number, limit: number): ng.IPromise<[any]> {
        return this.$q((resolve, reject) => {
            this.$http({
                method: "GET",
                url: this.portalURL + "?format=full&limit=" + limit + "&offset=" + offset,
                headers: this.authService.getRequestHeader()
            })
                .then((response) => {
                    resolve(response.data["data"]);
                });
        });
    }

    /**
    * Method request for the list of files received by a user from a given peer (i.e. inside a given conversation)
    * 
    * @param {string} userId [required] dbId of user making the request
    * @param {string} peerId [required] dbId of peer user in the conversation
    * @returns {ng.IPromise<IFileDescriptor[]>} : list of received files descriptors 
    * 
    * @memberOf FileStorageService
    */
    public retrieveFilesReceivedFromPeer(userId: string, peerId: string): ng.IPromise<IFileDescriptor[]> {

        return this.$q((resolve, reject) => {
            this.$http({
                method: "GET",
                url: this.portalURL + "/viewers/" + userId + "?ownerId=" + peerId + "&format=full",
                headers: this.authService.getRequestHeader()
            })
                .then((response) => {
                    let receivedFileDescriptors = [];
                    let fileDescriptorsData = response.data["data"];
                    if (fileDescriptorsData) {
                        for (let fileDescriptorData of fileDescriptorsData) {
                            let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorData);
                            receivedFileDescriptors.push(fileDescriptor);
                        }
                    }
                    this.$log.info("[FileStorageService] retrieveFilesReceivedFromPeer success");
                    resolve(receivedFileDescriptors);
                })
                .catch((errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "retrieveFilesReceivedFromPeer");
                    this.$log.error("[FileStorageService] " + error.message);
                    reject(error);
                });
        });
    }

    /**
     * Method request for the list of files sent to a given peer (i.e. inside a given conversation)
     * 
     * @param {string} peerId [required] dbId of peer user in the conversation
     * @returns {ng.IPromise<IFileDescriptor[]>} : list of sent files descriptors 
     * 
     * @memberOf FileStorageService
     */
    public retrieveSentFiles(peerId: string): ng.IPromise<IFileDescriptor[]> {

        return this.$q((resolve, reject) => {
            this.$http({
                method: "GET",
                url: this.portalURL + "?format=full&viewerId=" + peerId,
                headers: this.authService.getRequestHeader()
            })
                .then((response) => {
                    let sentFilesDescriptors = [];
                    let fileDescriptorsData = response.data["data"];
                    if (fileDescriptorsData) {
                        for (let fileDescriptorData of fileDescriptorsData) {
                            let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorData);
                            sentFilesDescriptors.push(fileDescriptor);
                        }
                    }
                    this.$log.info("[FileStorageService] retrieveSentFiles success");
                    resolve(sentFilesDescriptors);
                })
                .catch((errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "retrieveSentFiles");
                    this.$log.error("[FileStorageService] " + error.message);
                    reject(error);
                });
        });
    }

    /**
     * Method request for the list of files received in a room
     * 
     * @param {string} roomId [required] Id of the room
     * @returns {ng.IPromise<IFileDescriptor[]>} : list of received files descriptors 
     * 
     * @memberOf FileStorageService
     */
    public retrieveReceivedFilesForRoom(roomId: string): ng.IPromise<IFileDescriptor[]> {
        return this.$q((resolve, reject) => {
            this.$http({
                method: "GET",
                url: this.portalURL + "/viewers/" + roomId + "?format=full",
                headers: this.authService.getRequestHeader()
            })
                .then((response) => {
                    let fileDescriptorsData = response.data["data"];
                    if (!fileDescriptorsData) { resolve(); }

                    let result = [];
                    for (let fileDescriptorDataItem of fileDescriptorsData) {
                        fileDescriptorDataItem.viewers = [];
                        let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorDataItem);
                        if (fileDescriptor.ownerId !== this.contactService.userContact.dbId) {
                            result.push(fileDescriptor);
                        }
                    }
                    this.$log.info("[FileStorageService] retrieveReceivedFilesForRoom  -- success");
                    result = this.orderDocumentsForRoom(result);
                    resolve(result);
                })
                .catch((errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "retrieveReceivedFilesForRoom");
                    this.$log.error("[FileStorageService] " + error.message);
                    reject(error);
                });
        });
    }

    /**
     * Method request for the list of files received by a user
     * 
     * @param {string} viewerId [required] Id of the viewer, could be either an userId or a roomId
     * @returns {ng.IPromise<IFileDescriptor[]>} : list of received files descriptors 
     * 
     * @memberOf FileStorageService
     */
    public retrieveReceivedFiles(viewerId: string): ng.IPromise<IFileDescriptor[]> {

        return this.$q((resolve, reject) => {
            this.$http({
                method: "GET",
                url: this.portalURL + "/viewers/" + viewerId + "?format=full",
                headers: this.authService.getRequestHeader()
            })
                .then((response) => {
                    let fileDescriptorsData = response.data["data"];
                    if (!fileDescriptorsData) { 
                        resolve(); 
                        return;
                    }

                    for (let fileDescriptorItem of fileDescriptorsData) {
                        // fileDescriptorItem.viewers = [];
                        let fileDescriptor = this.createFileDescriptorFromData(fileDescriptorItem);

                        // filter files I sent but this are still returned by server because it is part of a room
                        if (fileDescriptor.ownerId !== this.contactService.userContact.dbId) {
                            let oldFileDesc = this.getFileDescriptorById(fileDescriptor.id);
                            if (oldFileDesc) { fileDescriptor.previewBlob = oldFileDesc.previewBlob; }
                            this.receivedFileDescriptors.push(fileDescriptor);
                        }
                    }
                    this.orderReceivedDocuments();
                    this.$log.info("[FileStorageService] retrieveReceivedFiles -- success");
                    resolve(this.receivedFileDescriptors);
                })
                .catch((errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "retrieveReceivedFiles");
                    this.$log.error("[FileStorageService] " + error.message);
                    reject(error);
                });
        });
    }

    /**
     * Method retrieve the data usage of a given user
     * 
     * @returns {ng.IPromise<{}>} : object data with the following properties: 
     *                  - feature {String} : The feature key belonging to the user's profile
     *                  - maxValue {number} : The quota associated to this offer [octet]
     *                  - currentValue {number} : The user's current consumption [octet]
     *                  - unit {String} : The unit of this counters 
     * @memberOf FileStorageService
     */
    public retrieveUserConsumption(): ng.IPromise<{}> {

        return this.$q((resolve, reject) => {
            this.$http({
                method: "GET",
                url: config.restServerUrl + "/api/rainbow/filestorage/v1.0/users/consumption",
                headers: this.authService.getRequestHeader()
            })
                .then((response) => {
                    this.consumptionData = response.data["data"];
                    this.$log.info("[FileStorageService] retrieveUserConsumption success");
                    resolve(this.consumptionData);
                })
                .catch((errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "retrieveUserConsumption");
                    this.$log.error("[FileStorageService] " + error.message);
                    reject(error);
                });
        });
    }

    /**
     * Method deletes a viewer from the list of viewer of a given file
     * 
     * @param {string} viewerId [required] Identifier of viewer to be removed. Could be either a user or a room
     * @param {string} fileId [required] Identifier of the fileDescriptor from which the viewer will be removed
     * @returns {ng.IPromise<{}>} 
     * 
     * @memberof FileStorageService
     */
    public deleteFileViewer(viewerId: string, fileId: string): ng.IPromise<{}> {

        return this.$q((resolve, reject) => {
            this.$http({
                method: "DELETE",
                url: this.portalURL + "/" + fileId + "/viewers/" + viewerId,
                headers: this.authService.getRequestHeader()
            }).then(
                (response) => {
                    this.$log.info("[FileStorageService] deleteFileViewer " + response.statusText);
                    // delete viewer from viewer list
                    let fd = this.getFileDescriptorById(fileId);
                    if (fd) {
                        let index = -1;
                        for (let i = 0; i < fd.viewers.length; i++) {
                            if (fd.viewers[i].viewerId === viewerId) {
                                index = i;
                                break;
                            }
                        }
                        if (index !== -1) {
                            fd.viewers.splice(index, 1);
                        }
                    }
                    resolve();
                },
                (errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "deleteFileViewer");
                    reject(error);
                    this.$log.error("[FileStorageService] " + error.message);
                });
        });

    }

    /**
     * Method adds a viewer to a given file on server if it is not already one
     * 
     * @param {string} fileId [required] Identifier of file
     * @param {string} viewerId [required] Identifier of viewer to be added
     * @param {string} viewerType [required] type of viewer to be added (user or room)
     * @returns {ng.IPromise<IFileDescriptor>} file descriptor with newly added viewer
     * 
     * @memberOf FileStorageService
     */
    public addFileViewer(fileId: string, viewerId: string, viewerType: string): ng.IPromise<IFileDescriptor> {

        let fileDescriptor = this.getFileDescriptorById(fileId);
        if (fileDescriptor && fileDescriptor.isAlreadyFileViewer(viewerId)) {
            return this.$q.resolve(fileDescriptor);
        }

        return this.$q((resolve, reject) => {
            this.$http({
                method: "POST",
                url: this.portalURL + "/" + fileId + "/viewers",
                headers: this.authService.getRequestHeader(),
                data: {
                    viewerId: viewerId,
                    type: viewerType
                }
            }).then(
                (response: any) => {
                    this.$log.info("[FileStorageService] addFileViewer success");
                    let fd = this.getFileDescriptorById(fileId);
                    if (fd) {
                        var viewerAdded = this.fileViewerFactory([{
                            viewerId: response.data.data.viewerId,
                            type: response.data.data.type
                        }])[0];
                        if (viewerAdded.type === "user") {
                            this.contactService.getContactByDBId(viewerId)
                                .then((contact) => {
                                    viewerAdded.contact = contact;
                                    fd.viewers.push(viewerAdded);
                                    resolve(fd);
                                })
                                .catch((error) => {
                                    this.$log.error("[FileStorageService] " + error);
                                    reject(error);
                                });
                        } else {
                            fd.viewers.push(viewerAdded);
                            resolve(fd);
                        }
                    }
                },
                (errorResponse) => {
                    const error = this.errorHelperService.handleError(errorResponse, "addFileViewer");
                    reject(error);
                    this.$log.error("[FileStorageService] " + error.message);
                });
        });
    }

    /** 
     * Method retrieve a specific file descriptor from server
     * 
     * @param {string} fileId [required] Identifier of file descriptor to retrieve
     * @returns {ng.IPromise<IFileDescriptor>} file descriptor retrieved
     * 
     * @memberOf FileStorageService
     */
    public retrieveOneFileDescriptor(fileId: string): ng.IPromise<IFileDescriptor> {

        return this.$q((resolve, reject) => {
            this.$http({
                method: "GET",
                url: this.portalURL + "/" + fileId + "?format=full",
                headers: this.authService.getRequestHeader()
            })
                .then((response) => {
                    let fileDescriptor = this.createFileDescriptorFromData(response.data["data"]);
                    this.$log.info("[FileStorageService] getOneFileDescriptor " + fileId + " -- success");
                    resolve(fileDescriptor);
                })
                .catch((errorResponse) => {
                    let error = this.errorHelperService.handleError(errorResponse, "getOneFileDescriptor");
                    this.$log.error("[FileStorageService] " + error.message);
                    reject(error);
                });
        });
    }

    /**
     * Method retrieve a specific file descriptor from server and stores it in local fileDescriptors (replace existing and add if new)
     * 
     * @param {string} fileId [required] Identifier of file descriptor to retrieve
     * @returns {ng.IPromise<IFileDescriptor>} file descriptor retrieved or null if none found
     * 
     * @memberOf FileStorageService
     */
    public retrieveAndStoreOneFileDescriptor(fileId: string, forceRetrieve: boolean): ng.IPromise<any> {
        
        let fileDescriptor = this.getFileDescriptorById(fileId);
        if (fileDescriptor && !forceRetrieve) {
            this.$log.info("[FileStorageService] retrieveAndStoreOneFileDescriptor -- return existing fileDescriptor " + fileId);
            return this.$q.resolve(fileDescriptor);
        }

        return this.retrieveOneFileDescriptor(fileId)
            .then((retrievedFileDescriptor: IFileDescriptor) => {

                if (fileDescriptor && fileDescriptor.isImage()) {
                    retrievedFileDescriptor.previewBlob = fileDescriptor.previewBlob;
                }

                // Remove old file descriptor with same id if there's one
                let oldFileDescriptorIndex = this.helpersService.findIndex(this.fileDescriptors, (_fileDescriptor) => { return _fileDescriptor.id === retrievedFileDescriptor.id; });
                if (oldFileDescriptorIndex > -1) {
                    this.fileDescriptors.splice(oldFileDescriptorIndex, 1);
                }
                let oldReceivedFileDescriptorIndex = this.helpersService.findIndex(this.receivedFileDescriptors, (_fileDescriptor) => { return _fileDescriptor.id === retrievedFileDescriptor.id; });
                if (oldReceivedFileDescriptorIndex > -1) {
                    this.receivedFileDescriptors.splice(oldReceivedFileDescriptorIndex, 1);
                }
                
                if (retrievedFileDescriptor.ownerId === this.contactService.userContact.dbId) { // The file is mine
                    this.fileDescriptors.push(retrievedFileDescriptor);
                    this.$log.info("[FileStorageService] retrieveAndStoreOneFileDescriptor -- fileDescriptor " + retrievedFileDescriptor.id + " -- now stored in my files");
                } else { // The file is not mine
                    let retrievedFileDescriptors = [];
                    this.receivedFileDescriptors.push(retrievedFileDescriptor);
                    this.$log.info("[FileStorageService] retrieveAndStoreOneFileDescriptor -- fileDescriptor " + retrievedFileDescriptor.id + " -- now stored in received files");
                    
                    this.$rootScope.$broadcast("ON_MESSAGE_WITH_FILE_RECEIVED_EVENT");
                }
                this.orderDocuments();
                this.$rootScope.$broadcast("ON_FILE_DESCRIPTOR_RECEIVED_EVENT", { fileId: retrievedFileDescriptor.id });

                return this.$q.resolve(retrievedFileDescriptor);
            })
            .catch((errorResponse) => {
                this.$log.warn("[FileStorageService] Error on getting FileDescriptor: " + errorResponse.errorDetailsCode);
                let error = this.errorHelperService.handleError(errorResponse, "retrieveAndStoreOneFileDescriptor");
                if (error.status >= 400 && error.status < 500) {
                    if (fileDescriptor) {
                        // ATTENTION MODIFIED BY MCO
                        //if (error.status === 404) { fileDescriptor.state = "deleted"; } 
                        //else { this.deleteFileDescriptorFromCache(fileDescriptor.id, true); }
                        if (error.status === 404) { this.deleteFileDescriptorFromCache(fileDescriptor.id, true); }

                        this.orderDocuments();
                        this.$log.debug("[FileStorageService] Sending ON_FILE_REMOVED_FROM_STORE_EVENT");
                        this.$rootScope.$broadcast("ON_FILE_REMOVED_FROM_STORE_EVENT", { fileId: fileDescriptor.id });
                    }
                }

                return this.$q.reject(errorResponse);
            });
    }

    // public SharePubliclyAFile(fileId: string): ng.IPromise<{}> {
    //     
    //     return this.$q((resolve, reject) => {
    //         this.$http({
    //             method: "POST",
    //             url: this.portalURL + "/" + fileId + "/share",
    //             headers: this.authService.getRequestHeader()
    //         }).then(
    //             response => {
    //                 let fileDescriptorData = response.data["data"];
    //                 this.$log.info("[FileStorageService] SharePubliclyAFile success");
    //                 resolve(fileDescriptorData);
    //             },
    //             errorResponse => {
    //                 let error = this.errorHelperService.handleError(response);
    //                 reject(error);
    //                 this.$log.error("[FileStorageService] " + errorHelperService.getErrorFullMessage(response, "SharePubliclyAFile"));
    //             });
    //     });
    // }

    // public StopThePublicFileSharing(fileId: string): ng.IPromise<{}> {
    //     return this.$q((resolve, reject) => {
    //         this.$http({
    //             method: "DELETE",
    //             url: this.portalURL + "/" + fileId + "/stop-share",
    //             headers: this.authService.getRequestHeader()
    //         }).then(
    //             response => {
    //                 let fileDescriptorData = response.data.data;
    //                 this.$log.info("[FileStorageService] StopThePublicFileSharing success");
    //                 resolve(fileDescriptorData);
    //             },
    //             errorResponse => {
    //                 let error = this.errorHelperService.handleError(response);
    //                 reject(error);
    //                 this.$log.error("[FileStorageService] " + errorHelperService.getErrorFullMessage(response, "StopThePublicFileSharing"));
    //             });
    //     });
    // }

    /**********************************************************/
    /**  Utilities                                           **/
    /**********************************************************/

    public deleteFileDescriptorFromCache(id, forceDelete) {
        this.$log.info("[FileStorageService] deleteFileDescriptorFromCache " + id);

        for (let index = 0; index < this.receivedFileDescriptors.length; index++) {
            if (this.receivedFileDescriptors[index].id === id) {
                this.receivedFileDescriptors.splice(index, 1);
                break;
            }
        }

        for (let index = 0; index < this.fileDescriptors.length; index++) {
            if (this.fileDescriptors[index].id === id) {
                if (forceDelete) { this.fileDescriptors.splice(index, 1); }
                else { this.fileDescriptors[index].state = "deleted"; }
                break;
            }
        }
        this.orderDocuments();
    }

    public orderDocuments() {
        this.$log.debug("[FileStorageService] orderDocuments: " + this.fileDescriptors.length);
        this.replaceOrderedByFilter(this.fileDescriptorsByDate, this.fileDescriptors, this.getDate, false, this.sortByDate);
        this.replaceOrderedByFilter(this.fileDescriptorsByName, this.fileDescriptors, this.getName, false, this.sortByName);
        this.replaceOrderedByFilter(this.fileDescriptorsBySize, this.fileDescriptors, this.getSize, false, this.sortBySize);
        this.orderReceivedDocuments();
    }

    public orderReceivedDocuments() {
        this.$log.debug("[FileStorageService] orderReceivedDocuments: " + this.receivedFileDescriptors.length);
        this.replaceOrderedByFilter(this.receivedFileDescriptorsByName, this.receivedFileDescriptors, this.getName, false, this.sortByName);
        this.replaceOrderedByFilter(this.receivedFileDescriptorsByDate, this.receivedFileDescriptors, this.getDate, false, this.sortByDate);
        this.replaceOrderedByFilter(this.receivedFileDescriptorsBySize, this.receivedFileDescriptors, this.getSize, false, this.sortBySize);
    }

    public orderDocumentsForRoom(documents) {
        return this.orderByFilter(documents, this.getDate, false, this.sortByDate);
    }

    public replaceOrderedByFilter(resultArray, originalArray, filterFct, flag, sortFct) {
        this.$log.debug("[FileStorageService] replaceOrderedByFilter");

        resultArray.length = 0;
        let orderedArrayResult = this.orderByFilter(originalArray, filterFct, flag, sortFct);
        for (let fileResult of orderedArrayResult) {
            if (fileResult.state !== "deleted") {
                resultArray.push(fileResult);
            }
        }
    }

    public getName(file) {
        let result = { name: "", date: "" };
        if (file.fileName) { result.name = file.fileName; }
        let date;
        if (file.uploadedDate) { date = new Date(file.uploadedDate); }
        else if (file.registrationDate) { date = new Date(file.registrationDate); }
        else { date = new Date(file.dateToSort); }
        result.date = date.getTime();
        return result;
    }

    public getDate(file) {
        let date;
        if (file.uploadedDate) { date = new Date(file.uploadedDate); }
        else if (file.registrationDate) { date = new Date(file.registrationDate); }
        else { date = new Date(file.dateToSort); }
        return date.getTime();
    }

    public getSize(file) {
        let result = { name: "", size: "" };
        if (file.name) { result.name = file.fileName; }
        result.size = file.size;
        return result;
    }

    public sortByName(fileA, fileB) {
        let res = -1;
        if (fileA.value.name && fileB.value.name) {
            res = fileA.value.name.localeCompare(fileB.value.name);
            if (res === 0) { res = fileB.value.date - fileA.value.date; }
        }
        return res;
    }

    public sortBySize(fileA, fileB) {
        let res = -1;
        if (fileA.value.size && fileB.value.size) { res = fileB.value.size - fileA.value.size; }
        return res;
    }

    public sortByDate(fileA, fileB) {
        let res = 1;
        if (fileA && fileB) { res = fileB.value - fileA.value; }
        return res;
    }

    /**
     * Method extract fileId part of URL
     * 
     * @param {string} url 
     * @returns {string} 
     * 
     * @memberof FileStorageService
     */
    public extractFileIdFromUrl(url: string): string {
        let parts = url.split("/");
        let fileDescriptorId = parts.pop() || parts.pop();
        return fileDescriptorId;
    }
}
angular.module("rainbow").service("fileStorageService", FileStorageService);