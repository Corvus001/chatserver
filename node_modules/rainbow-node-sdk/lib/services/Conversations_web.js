"use strict";

var Error = require("../common/Error");

const LOG_ID = "CONVERSATIONS - ";

/**
 * @class
 * @name Conversations
 * @description
 *       This module manages conversations. A contact is defined by a set of public information (name, firstname, avatar...) and a set of private information.<br>
 *       Using this module, you can get access to your network contacts or search for Rainbow contacts.
 *      <br><br>
 *      The main methods proposed in that module allow to: <br>
 *      - Get the network contacts (roster) <br>
 *      - Get and search contacts by Id, JID or loginEmail <br>
 */
class Conversations {

    constructor(_eventEmitter, _logger) {
        this.xmpp = null;
        this.conversations = null;
        this.eventEmitter = _eventEmitter;
        this.logger = _logger;
    }

    start(_xmpp, _rest) {

        var that = this;

        this
            .logger
            .log("debug", LOG_ID + "(start) _entering_");

        return new Promise(function (resolve, reject) {
            try {
                that.xmpp = _xmpp;
                that.rest = _rest;
                that.conversations = [];
                that
                    .eventEmitter
                    .on("rainbow_conversationremoved", that._onConversationRemoved.bind(that));
                that
                    .eventEmitter
                    .on("rainbow_conversationchanged", that._onConversationReceived.bind(that));
                that
                    .eventEmitter
                    .on("rainbow_conversationschanged", that._onConversationsChanged.bind(that));
                that
                    .eventEmitter
                    .on("rainbow_conversationsmissedcounterchanged", that._onConversationMissedCounterChanged.bind(that));
                that
                    .logger
                    .log("debug", LOG_ID + "(start) _exiting_");
                resolve();

            } catch (err) {
                that
                    ._logger
                    .log("debug", LOG_ID + "(start) _exiting_");
                reject();
            }
        });
    }

    stop() {
        var that = this;

        this
            .logger
            .log("debug", LOG_ID + "(stop) _entering_");

        return new Promise(function (resolve, reject) {
            try {
                that.xmpp = null;
                that.rest = null;
                that.conversations = null;
                that
                    .eventEmitter
                    .removeListener("rainbow_conversationremoved", that._onConversationRemoved);
                that
                    .eventEmitter
                    .removeListener("rainbow_conversationchanged", that._onConversationReceived);
                that
                    .eventEmitter
                    .removeListener("rainbow_conversationschanged", that._onConversationsChanged);
                that
                    .eventEmitter
                    .removeListener("rainbow_conversationsmissedcounterchanged", that._onConversationMissedCounterChanged);
                that
                    .logger
                    .log("debug", LOG_ID + "(stop) _exiting_");
                resolve();

            } catch (err) {
                that
                    ._logger
                    .log("debug", LOG_ID + "(stop) _exiting_");
                reject();
            }
        });
    }

    /**
         * @public
         * @method
         * @instance
         * @description
         *    Allow to get the list of existing conversations (p2p and bubbles)
         * @return {Conversation[]} An array of Conversation object
         */
    getAllConversations() {
        var allConversations = conversationService.getConversations();

        var oneToOneConversationsOnly = [];

        allConversations.forEach(function (conversation) {
            oneToOneConversationsOnly.push(conversation);
        });

        return oneToOneConversationsOnly;
    }

    /**
         * @public
         * @since 1.19.0
         * @method
         * @instance
         * @description
         *    Get a call by its Id by searching on all user's conversations
         * @param {String} strCallId ID of the call
         * @return {Call} The call if found or an error
         */
    getCallByID(strCallId) {

        if (!strCallId) {
            return ({code: SDK.ERRORBADREQUEST, label: "Parameter 'strCallId' is missing or empty"});
        }

        var allConversations = conversationService.getConversations();
        var call = null;

        allConversations.forEach(function (conversation) {
            if (conversation.videoCall && conversation.videoCall.id === strCallId) {
                call = conversation.videoCall;
            } else if (conversation.audioCall && conversation.audioCall.id === strCallId) {
                call = conversation.audioCall;
            }
        });
        return call;
    }

    /**
         * @public
         * @since 1.16.0
         * @method
         * @instance
         * @description
         *    Get a conversation by its id
         * @param {String} strId ID of the conversation
         * @return {Conversation} A conversation object or null if not found
         */
    getConversationById(strId) {

        if (!strId) {
            return ({code: SDK.ERRORBADREQUEST, label: "Parameter 'callId' is missing or empty"});
        }

        return conversationService.getConversationById(strId);
    }

    /**
         * @public
         * @since 1.19.0
         * @method
         * @instance
         * @description
         *    Get a conversation associated to a bubble (using the bubble ID to retrieve it)
         * @param {String} strBubbleId ID of the bubble (dbId field)
         * @return {Conversation} A conversation object or null if not found
         */
    getConversationByBubbleId(strBubbleId) {

        if (!strBubbleId) {
            return ({code: SDK.ERRORBADREQUEST, label: "Parameter 'strBubbleId' is missing or empty"});
        }

        return conversationService.getConversationByRoomDbId(strBubbleId);
    }

    /**
         * @public
         * @method
         * @instance
         * @description
         *    Open a conversation to a contact <br/>
         *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>
         *    This method returns a promise
         * @param {Contact} contact The contact involved in the conversation
         * @return {Conversation} The conversation (created or retrieved) or null in case of error
         */
    openConversationForContact(contact) {
        var defered = $q.defer();

        if (!contact) {
            defered.reject({code: SDK.ERRORBADREQUEST, label: "Parameter 'contact' is missing or null"});
        } else {
            $log.sdk(logService + "[createConve] :: Try to create of get a conversation with " + contact.lastname + " " + contact.firstname);

            conversationService
                .getOrCreateOneToOneConversation(contact.jid)
                .then(function (conversation) {
                    $log.sdk(logService + "[createConve] :: Conversation retrieved or created " + conversation.id);
                    defered.resolve(conversation);
                })
                .catch(function (result) {
                    $log.sdk(logService + "[createConve] :: Error");
                    defered.reject(result);
                });
        }
        return defered.promise;
    }

    /**
         * @public
         * @method
         * @since 1.22
         * @instance
         * @description
         *    Open a conversation to a bubble <br/>
         *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>
         *    This method returns a promise
         * @param {Bubble} bubble The bubble involved in this conversation
         * @return {Conversation} The conversation (created or retrieved) or null in case of error
         */
    openConversationForBubble(bubble) {
        var defered = $q.defer();

        if (!bubble) {
            defered.reject({code: SDK.ERRORBADREQUEST, label: "Parameter 'bubble' is missing or null"});
        } else {
            $log.sdk(logService + "[createConve] :: Try to create or get a conversation for a bubble " + bubble.name + "(" + bubble.id + ")");

            conversationService
                .getBubbleConversation(bubble.jid)
                .then(function (conversation) {
                    $log.sdk(logService + "[createConve] :: Conversation retrieved or created " + conversation.id);
                    defered.resolve(conversation);
                })
                .catch(function (result) {
                    $log.sdk(logService + "[createConve] :: Error");
                    defered.reject(result);
                });
        }
        return defered.promise;
    }

    /**
     * @public
     * @method
     * @instance
     * @description
     *    Close a conversation <br/>
     *    This method returns a promise
     * @param {Conversation} conversation The conversation to close
     */
    closeConversation(conversation) {
        var defered = $q.defer();

        if (!conversation) {
            defered.reject({code: SDK.ERRORBADREQUEST, label: "Parameter 'conversation' is missing or null"});
        } else {
            conversationService
                .closeConversation(conversation)
                .then(function () {
                    defered.resolve(null);
                })
                .catch(function (result) {
                    defered.reject(result);
                });
        }

        return defered.promise;
    }
}

module.exports = Conversations;